<h4>State Encoding Techniques</h4><p>XST supports the following state encoding techniques.</p><ul><li><p>Auto</p></li><li><p>One-Hot</p></li><li><p>Gray</p></li><li><p>Compact</p></li><li><p>Johnson</p></li><li><p>Sequential</p></li><li><p>User</p></li></ul><h4>Auto</h4><p>In this mode XST tries to select the best suited encoding algorithm for each FSM.</p><h4>One-Hot</h4><p>One-hot encoding is the default encoding scheme. Its principle is to associate one code bit and also one flip-flop to each state. At a given clock cycle during operation, one and only one state variable is asserted. Only two state variables toggle during a transition between two states. One-hot encoding is very appropriate with most FPGA targets where a large number of flip-flops are available. It is also a good alternative when trying to optimize speed or to reduce power dissipation.</p><h4>Gray</h4><p>Gray encoding guarantees that only one state variable switches between two consecutive states. It is appropriate for controllers exhibiting long paths without branching. In addition, this coding technique minimizes hazards and glitches. Very good results can be obtained when implementing the state register with T flip-flops.</p><h4>Compact</h4><p>Compact encoding, consists of minimizing the number of state variables and flip-flops. This technique is based on hypercube immersion. Compact encoding is appropriate when trying to optimize area.</p><h4>Johnson</h4><p>Like Gray, Johnson encoding shows benefits with state machines containing long paths with no branching.</p><h4>Sequential</h4><p>Sequential encoding consists of identifying long paths and applying successive radix two codes to the states on these paths. Next state equations are minimized.</p><h4>User</h4><p>In this mode, XST uses original encoding, specified in the HDL file. For example, if you use enumerated types for a state register, then in addition you can use the <strong>enum_encoding</strong> constraint to assign a specific binary value to each state. </p>